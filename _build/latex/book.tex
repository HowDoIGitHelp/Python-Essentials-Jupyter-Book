%% Generated by Sphinx.
\def\sphinxdocclass{jupyterBook}
\documentclass[letterpaper,10pt,english]{jupyterBook}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}
%% memoir class requires extra handling
\makeatletter\@ifclassloaded{memoir}
{\ifdefined\memhyperindexfalse\memhyperindexfalse\fi}{}\makeatother

\PassOptionsToPackage{booktabs}{sphinx}
\PassOptionsToPackage{colorrows}{sphinx}

\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{fontspec}
\defaultfontfeatures[\rmfamily,\sffamily,\ttfamily]{}
\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{english}



\setmainfont{FreeSerif}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Italic,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldItalic
]
\setsansfont{FreeSans}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]
\setmonofont{FreeMono}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]



\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}



        % Start of preamble defined in sphinx-jupyterbook-latex %
         \usepackage[Latin,Greek]{ucharclasses}
        \usepackage{unicode-math}
        % fixing title of the toc
        \addto\captionsenglish{\renewcommand{\contentsname}{Contents}}
        \hypersetup{
            pdfencoding=auto,
            psdextra
        }
        % End of preamble defined in sphinx-jupyterbook-latex %
        

\title{Python Programming Fundamentals}
\date{Jun 19, 2024}
\release{}
\author{Eli Edrian Tan, Rubelito Abella}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{intro::doc}}


\sphinxAtStartPar
To kickstart the training program, well start off with one of the most important tools in data science: python.

\sphinxAtStartPar
Python is used for diverse tasks in the data science pipeline. From data cleaning, data exploration, statistical analysis, visualization, model building, presentation, etc.

\sphinxAtStartPar
In this section of the training you will learn the basics of python programming.

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\Large Python is easy}
\end{DUlineblock}

\sphinxAtStartPar
Python is designed to be close to natural language. It was created to promote readability, maintainability and communication. Instead of dedicating the time to learn difficult syntax, you can easily jump into writing python scripts.

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Python is well supported}
\end{DUlineblock}

\sphinxAtStartPar
Python is not only well\sphinxhyphen{}loved in data science, it is well\sphinxhyphen{}loved across many fields. Because of this python enjoys the support of a strong and passionate community that loves to contribute new libraries and tools.

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Python tools for Data Science}
\end{DUlineblock}

\sphinxAtStartPar
Throughout this training course you will be learning python and the tools associated to python for data science.

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large pandas}
\end{DUlineblock}

\sphinxAtStartPar
\sphinxhref{https://pandas.pydata.org/}{pandas} is used for all data cleaning, data exploration, data analysis. With pandas you’re able to structure data in an intuitive way, you’re able to manipulate data easily, and seamlessly

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large numpy}
\end{DUlineblock}

\sphinxAtStartPar
\sphinxhref{https://numpy.org/}{numpy} is the heart of almost every involving vectorized operations in python. You will use numpy when you’re interacting with numerical data,

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large matplotlib}
\end{DUlineblock}

\sphinxAtStartPar
\sphinxhref{https://matplotlib.org/}{matplotlib} is used for creating rich customizable visualizatio. You will matplotlib to explore data, evaluate models, and present results

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large scikit\sphinxhyphen{}learn}
\end{DUlineblock}

\sphinxAtStartPar
\sphinxhref{https://scikit-learn.org/stable/}{scikit\sphinxhyphen{}learn} offers a wide library of machine learning models. It allows you to tune, cross validate, and evaluate models

\sphinxAtStartPar
Table of Contents
\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{installing-python::doc}]{\sphinxcrossref{Installing Python}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{jupyter-notebooks::doc}]{\sphinxcrossref{Jupyter Notebooks}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{expressions::doc}]{\sphinxcrossref{Expressions}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{datatypes::doc}]{\sphinxcrossref{Datatypes}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{first-program::doc}]{\sphinxcrossref{First program}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{conditionals::doc}]{\sphinxcrossref{Conditionals}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{loops::doc}]{\sphinxcrossref{Loops}}}

\end{itemize}

\sphinxstepscope


\chapter{Installing Python}
\label{\detokenize{installing-python:installing-python}}\label{\detokenize{installing-python::doc}}

\section{Anaconda python}
\label{\detokenize{installing-python:anaconda-python}}
\sphinxAtStartPar
Installing anaconda python comes with with useful resources. The anaconda install comes with python 3, jupyter, conda environment and more:
You can download anaconda through the \sphinxhref{https://www.anaconda.com/download/success}{anaconda download page}.

\sphinxAtStartPar
Choose the correct installer for your operating system

\sphinxAtStartPar
\sphinxincludegraphics{{anaconda_download_page}.png}

\sphinxAtStartPar
Install the anaconda using the installer. To avoid issues try to choose an installation path that does not contain any spaces. The installer will warn you about this.

\sphinxAtStartPar
You can just follow the default installation choices from here.

\sphinxAtStartPar
\sphinxincludegraphics{{anaconda_installation}.png}

\sphinxAtStartPar
If successfully installed, the installer will install the following tools to your computer:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Python

\item {} 
\sphinxAtStartPar
Anaconda Prompt

\item {} 
\sphinxAtStartPar
Anaconda Navigator

\item {} 
\sphinxAtStartPar
Jupyter Notebook

\item {} 
\sphinxAtStartPar
Jupyter Lab

\item {} 
\sphinxAtStartPar
Spyder IDE

\end{itemize}

\sphinxAtStartPar
To verify your python installation you can run anaconda prompt. It will open the anaconda terminal. From the terminal you can use anaconda’s command line tools.

\sphinxAtStartPar
Type the command \sphinxcode{\sphinxupquote{python}} and press enter:

\sphinxAtStartPar
\sphinxincludegraphics{{python_command}.png}

\sphinxAtStartPar
If everything is good, anaconda prompt should send you to the python interpreter

\sphinxAtStartPar
\sphinxincludegraphics{{python_interpreter}.png}

\sphinxAtStartPar
You can now use the anaconda terminal to run python scripts


\section{Adding python to your PATH variable}
\label{\detokenize{installing-python:adding-python-to-your-path-variable}}
\sphinxAtStartPar
If you want to use python in your own terminal, you can add the python executable in your PATH variable.
The way to do this will depend on your operating system.
Check the guides below for updating the value of PATH:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://www.computerhope.com/issues/ch000549.htm}{Windows}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://mac.install.guide/terminal/path}{Mac/Linux}

\end{itemize}

\sphinxAtStartPar
If you’re successful in adding python to yout PATH variable, you should be able to run the \sphinxcode{\sphinxupquote{python}} command in your terminal of choice
\begin{quote}

\sphinxAtStartPar
If you already have a python installation in your machine, this is not advised.

\sphinxAtStartPar
For newer version of windows, running the \sphinxcode{\sphinxupquote{python}} command may redirect you to the Microsoft Store Download Page for python. To change this, find the setting “App execution aliases” and toggle off the option for App Installer\sphinxhyphen{}python.exe and App Installer\sphinxhyphen{}python3.exe
\end{quote}


\section{Python Standalone}
\label{\detokenize{installing-python:python-standalone}}
\sphinxAtStartPar
If you do not want to install the anaconda tool stack. You can also opt to install the python by itself.
You can follow the instructions on \sphinxhref{https://www.python.org/downloads/}{python’s download page}

\sphinxAtStartPar
If you do choose to install python by itself you will also need to manually install jupyter, which will be used in this training course. You can select between jupyter lab and jupyter notebook, or even install it as a plugin in VSCode. You can find installation instructions in the \sphinxhref{https://jupyter.org/install}{jupyter page}

\sphinxstepscope


\chapter{Jupyter Notebooks}
\label{\detokenize{jupyter-notebooks:jupyter-notebooks}}\label{\detokenize{jupyter-notebooks::doc}}
\sphinxAtStartPar
Throughout this training course, you will be using jupyter to write python code, perform data analysis, present results, create visualization, and more.
Jupyter notebooks offer data scientists a way to build interactive environments that combine code, documentation, and output. In fact the lecture notes that you will be reading are written in jupyter notebooks.


\section{Launching Jupyter notebook}
\label{\detokenize{jupyter-notebooks:launching-jupyter-notebook}}
\sphinxAtStartPar
If you installed python through the anaconda distribution, you should be able to launch Jupyter Notebook or Jupyter Lab in Anaconda Navigator.
You can also launch them through Anacaonda Prompt. Just run the commands \sphinxcode{\sphinxupquote{jupyter lab}} or \sphinxcode{\sphinxupquote{jupyter notebook}}. You can select either jupyter lab or jupyter notebook.

\sphinxAtStartPar
\sphinxincludegraphics{{anaconda_navigator}.png}

\sphinxAtStartPar
It’s up to you on which environment you prefer. Both of them will run through your browser.


\section{Creating notebooks}
\label{\detokenize{jupyter-notebooks:creating-notebooks}}
\sphinxAtStartPar
Once you’ve launched jupyter through either lab/notebook, you should be able to see a file explorer page/tab.

\sphinxAtStartPar
\sphinxincludegraphics{{jupyter_notebook_explorer}.png}

\sphinxAtStartPar
\sphinxincludegraphics{{jupyter_lab_explorer}.png}

\sphinxAtStartPar
The file explorer shows the directory where you installed anaconda or where your ran the command. From here you can navigate to the folder of your choice and create a new notebook. When creating a notebook, jupyter might ask you to select a kernel. Choose Python3 (ipykernel).


\section{Interacting with python through Jupyter Notebooks}
\label{\detokenize{jupyter-notebooks:interacting-with-python-through-jupyter-notebooks}}
\sphinxAtStartPar
Jupyter notebooks are composed of cells. Cells can either contain code, markdown, or raw text. With an new notebook you start with one code cell

\sphinxAtStartPar
\sphinxincludegraphics{{jupyter_notebook_empty}.png}

\sphinxAtStartPar
Click on the cell to edit it. Since this is a code cell, it is expecting python code.
We can write a python expression here

\sphinxAtStartPar
\sphinxincludegraphics{{jupyter_code_cell}.png}

\sphinxAtStartPar
While the cell is selected, you can press Shift+Enter to run the cell (note how this also automatically adds an empty code cell in the bottom). When a code cell is run the code inside it will be executed. It will also check the last line of the cell and try to print its evaluation.

\sphinxAtStartPar
\sphinxincludegraphics{{jupyter_outputs}.png}

\sphinxAtStartPar
In the example above we have created a new cell and added two lines of expression. Notice how in the second cell, there is only one output. As said before, the cells output will automatically display the evaluation of the last line of code.

\sphinxAtStartPar
You can also force jupyter to display other things by explicitly calling python’s \sphinxcode{\sphinxupquote{print()}} function

\sphinxAtStartPar
\sphinxincludegraphics{{jupyter_cells_printing}.png}

\sphinxAtStartPar
If you want to change the cell type of a cell, you can select the desired type in the dropdown found in the tool bar. Other than code cells, you can choose between raw text cells, and markdown cells. Raw text cells will simply render the text placed inside it, while markdown cells will render the text with markdown formatting. Raw text cells and markdown cells are not executed by jupyter. Use these cells to add narratives or documentation.

\sphinxAtStartPar
For more detailed tutorials, tips, and tricks on how to use Jupyter you check the following external resource:

\sphinxAtStartPar
\sphinxhref{https://www.dataquest.io/blog/jupyter-notebook-tutorial/}{How to Use Jupyter Notebook: A Beginner’s Tutorial}

\sphinxstepscope


\chapter{Expressions}
\label{\detokenize{expressions:expressions}}\label{\detokenize{expressions::doc}}
\sphinxAtStartPar
Expressions are the building blocks of programming. It is used to represent values. It can also be combined with other expressions to create more expressions.


\section{Literals}
\label{\detokenize{expressions:literals}}
\sphinxAtStartPar
Literals are the simplest forms of expressions. Just like any expression, literals represent some type of value. Literals are values that represent their value in a ‘literal’ sense. See the examples below. These expressions are literals

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{2}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
2
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{this}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}this\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kc}{True}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
You can see why they represent their value in a \sphinxstyleemphasis{literal} sense. The literal \sphinxcode{\sphinxupquote{2}} \sphinxstyleemphasis{literally} represents the integer value 2. The literal \sphinxcode{\sphinxupquote{this}} represents the word \sphinxcode{\sphinxupquote{this}}. As seen in the examples above, literals (and expressions in general) can come in the form of numbers, words, truth values, and more. We will learn about the different types of values expressions can be in the topic \sphinxstylestrong{Datatypes}.


\section{Combining Expressions}
\label{\detokenize{expressions:combining-expressions}}
\sphinxAtStartPar
Expression in python and programming are patterned after mathematical expressions. In the same way you can combine mathematical expressions, you can also combine programming expressions based on predefined rules. For example we can combine two integer literal expressions using addition and we will get a compound expression

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
3
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
The expression \sphinxcode{\sphinxupquote{2 + 1}} is a combination of the literals \sphinxcode{\sphinxupquote{2}} and \sphinxcode{\sphinxupquote{1}} using addition. The expression is combined using addition through the use of the operator \sphinxcode{\sphinxupquote{+}}.

\sphinxAtStartPar
As you can see when you run the cell above, it produces an output of \sphinxcode{\sphinxupquote{3}}. When you run said cell, you tell python to evaluate the expression \sphinxcode{\sphinxupquote{2 + 1}}. The evaluation of \sphinxcode{\sphinxupquote{2 + 1}} is simply the sum \sphinxcode{\sphinxupquote{3}}.

\sphinxAtStartPar
Since \sphinxcode{\sphinxupquote{2 + 1}} is also an expression, we can also combine it with other expressions through operations.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{4}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZhy{}1
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
When working with multiple operations in one expression, python follows predefined rules of precedence. On operators with the same amount of priority such as \sphinxcode{\sphinxupquote{+}} and \sphinxcode{\sphinxupquote{\sphinxhyphen{}}} in the cell above, python will combine the expressions from left to right. It will evaluate the leftmost expression first. In the case above it evaluates \sphinxcode{\sphinxupquote{2 + 1}} into 3 and then evaluates \sphinxcode{\sphinxupquote{3 \sphinxhyphen{} 4}} into \sphinxhyphen{}1.

\sphinxAtStartPar
In other cases some operators will take priority over other operators, regardless if it is to the left or to the right.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mi}{3} \PYG{o}{*} \PYG{l+m+mi}{2} 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
7
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{3} \PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{+} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
7
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
To promote code readability, you as a programmer can remove ambiguity by adding parentheses in your expressions. Expressions inside the \sphinxstylestrong{innermost} parentheses are prioritized above everything else

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{2}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
8
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{o}{+} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
20
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Variables}
\label{\detokenize{expressions:variables}}
\sphinxAtStartPar
Similar to math, another form of expression is the variable. It is called a variable because unlike literals, its value can \sphinxstylestrong{vary} depending on context.

\sphinxAtStartPar
To create a variable, you must assign it with a value.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{3}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
The cell above is known as an \sphinxstylestrong{asignment statement}. It is used to assign value to a variable. The variable in this case is named \sphinxcode{\sphinxupquote{x}}. There are also rules on the allowed names for variables. And beyond those rules there are conventions on proper name choices.
\begin{quote}

\sphinxAtStartPar
Note how the cell above doesnt have an output. This is because assignments statements are not an expressions that can be evaluated.
\end{quote}


\subsection{Rules for naming variables}
\label{\detokenize{expressions:rules-for-naming-variables}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Variable names must start with a letter or underscore

\item {} 
\sphinxAtStartPar
Variable names must be a combination of letters, numbers, and underscores

\item {} 
\sphinxAtStartPar
Variable names cannot be reserved words (words that are reserved for python syntax)

\end{itemize}


\subsection{Conventions for naming variables}
\label{\detokenize{expressions:conventions-for-naming-variables}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Variables must be descriptive \sphinxhyphen{} it should describe whatever it is representing

\item {} 
\sphinxAtStartPar
Variables must be concise \sphinxhyphen{} it shouldnt be so long that it makes code unreadable

\item {} 
\sphinxAtStartPar
And more…

\end{itemize}

\sphinxAtStartPar
If the rules are not followed, your variable name will produce an error in python. On the other hand conventions are not enforced by python. Not following conventions will still produce code that runs but it may result in code that is unreadable or hard to maintain.

\sphinxAtStartPar
The following are examples of well\sphinxhyphen{}named variables:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{size} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{n}{airport\PYGZus{}code} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{MNL}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{nCols} \PYG{o}{=} \PYG{l+m+mi}{12}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Variables are also expressions, so they can be used in the same way any other expressions are used. It can be combined through operations, or it can be evaluated as is.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{size}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
10
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{size} \PYG{o}{*} \PYG{l+m+mi}{2}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
20
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Since we assigned the value \sphinxcode{\sphinxupquote{10}} to \sphinxcode{\sphinxupquote{size}} in the previous cells, We can use it to represent the literal expresison \sphinxcode{\sphinxupquote{10}}.


\subsection{Assignment Statements}
\label{\detokenize{expressions:assignment-statements}}
\sphinxAtStartPar
True to its name, a variable’s value can change. To do this, we simply run another assignment statement

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{size} \PYG{o}{=} \PYG{l+m+mi}{15}
\PYG{n}{size}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
15
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
There are two parts to an assigment statement, the left\sphinxhyphen{}hand side (to the left of \sphinxcode{\sphinxupquote{=}}) represents the variable name, and the right\sphinxhyphen{}hand side (to the right of \sphinxcode{\sphinxupquote{=}}) represents the assigned expression. The left\sphinxhyphen{}hand side cannot be anything else other than a variable name. On the other hand you can put any expression on the right\sphinxhyphen{}hand side.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{size} \PYG{o}{=} \PYG{l+m+mi}{15} \PYG{o}{+} \PYG{l+m+mi}{3}
\PYG{n}{size}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
18
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{size1} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{n}{size2} \PYG{o}{=}  \PYG{l+m+mi}{20}
\PYG{n}{size3} \PYG{o}{=}  \PYG{n}{size1} \PYG{o}{+} \PYG{n}{size2}
\PYG{n}{size3}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
30
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{size} \PYG{o}{=} \PYG{n}{size} \PYG{o}{+} \PYG{l+m+mi}{3}
\PYG{n}{size}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
21
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
One source of confusion when it comes to assignment statements is the misconception that it is the same as the mathematical equality. It’s easy to make this misconception because after all, they use the same symbol (\sphinxcode{\sphinxupquote{=}}). When you see an assignment statement, instead of an equal sympbol, imagine an arrow pointing to the left.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{size} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZhy{}} \PYG{n}{size} \PYG{o}{+} \PYG{l+m+mi}{3}
\end{sphinxVerbatim}

\sphinxAtStartPar
Think of pushing the expression on the right\sphinxhyphen{}hand side into the variable in the left\sphinxhyphen{}hand side. The expression on the right\sphinxhyphen{}hand side will be evaluated, and whatever value it evaluates into, it will be pushed into the variable on the left\sphinxhyphen{}hand side, overwriting whatever value was originally inside. In the example \sphinxcode{\sphinxupquote{size = size + 3}}, the right\sphinxhyphen{}hand side, evaluates into 30 + 3 or 33. The value 33 is then pushed into \sphinxcode{\sphinxupquote{size}}. As a result the next time you evaluate \sphinxcode{\sphinxupquote{size}} by itself, it evaluates to 33.

\sphinxAtStartPar
The cell below shows what could happen if you repeatedly overwrite \sphinxcode{\sphinxupquote{size}} by adding 1 to it

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{size} \PYG{o}{=} \PYG{n}{size} \PYG{o}{+} \PYG{l+m+mi}{1}
\PYG{n}{size} \PYG{o}{=} \PYG{n}{size} \PYG{o}{+} \PYG{l+m+mi}{1}
\PYG{n}{size} \PYG{o}{=} \PYG{n}{size} \PYG{o}{+} \PYG{l+m+mi}{1}
\PYG{n}{size}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
24
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
There is a special name for the assignment statement \sphinxcode{\sphinxupquote{size = size + 3}} or \sphinxcode{\sphinxupquote{size = size + 1}}, these are called increments/decrements. It updates the value of an \sphinxstylestrong{existing} variable by a certain value. There is a shortcut for increment/decrement statements, which uses the \sphinxcode{\sphinxupquote{+=}} or \sphinxcode{\sphinxupquote{\sphinxhyphen{}=}} operator.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{size} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{n}{size} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{size}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
11
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{size2} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{n}{size2} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{l+m+mi}{5}
\PYG{n}{size2} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{l+m+mi}{2}
\PYG{n}{size2}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
3
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\chapter{Datatypes}
\label{\detokenize{datatypes:datatypes}}\label{\detokenize{datatypes::doc}}
\sphinxAtStartPar
Python supports plenty of literals and data types, most of these you can discover on your own.

\sphinxAtStartPar
For purposes of this module, we’ll only look at a few: \sphinxcode{\sphinxupquote{int}}, \sphinxcode{\sphinxupquote{float}}, \sphinxcode{\sphinxupquote{str}}, \sphinxcode{\sphinxupquote{bool}}, \sphinxcode{\sphinxupquote{list}}, and \sphinxcode{\sphinxupquote{dict}}.
However, we might come across the other data types along the way.


\section{Numerical types}
\label{\detokenize{datatypes:numerical-types}}
\sphinxAtStartPar
These types represent numbers and will play along well with the arithmetic operators.


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{int}}}
\label{\detokenize{datatypes:int}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{int}} datatype stores whole numbers and represents Mathematical integers.
Just like Mathematical integers, the \sphinxcode{\sphinxupquote{int}} datatype is unbounded.
That is, we can represent as big or as small numbers as we want.

\sphinxAtStartPar
Python also offers \sphinxcode{\sphinxupquote{int()}} to coerce values to be represented as an \sphinxcode{\sphinxupquote{int}}:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{int}\PYG{p}{(}\PYG{l+m+mf}{2.5}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
2
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{int}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{12345}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
12345
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{\sphinxstyleliteralintitle{\sphinxupquote{float}}}
\label{\detokenize{datatypes:float}}
\sphinxAtStartPar
Represents floating point numbers.
These are numbers that have a fractional part.

\sphinxAtStartPar
We also have \sphinxcode{\sphinxupquote{float()}} to coerce values to be a \sphinxcode{\sphinxupquote{float}}:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{float}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
2.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{float}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
0.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{float}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{123.456}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
123.456
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Mixing types}
\label{\detokenize{datatypes:mixing-types}}
\sphinxAtStartPar
Mixing \sphinxcode{\sphinxupquote{int}} and \sphinxcode{\sphinxupquote{float}} together in an expression will typically result in the \sphinxcode{\sphinxupquote{int}} being converted to a \sphinxcode{\sphinxupquote{float}} first.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{2.0} \PYG{o}{+} \PYG{l+m+mi}{3}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
5.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{5} \PYG{o}{*} \PYG{l+m+mf}{10.0}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
50.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{int}}, \sphinxcode{\sphinxupquote{3}}, is implicitly converted to a \sphinxcode{\sphinxupquote{float}} and then added with the other \sphinxcode{\sphinxupquote{float}}.
Thus, we get a \sphinxcode{\sphinxupquote{5.0}} as we’re adding two \sphinxcode{\sphinxupquote{float}}s.


\section{Text sequence type}
\label{\detokenize{datatypes:text-sequence-type}}
\sphinxAtStartPar
Python represents words and characters as strings.
Strings are immutable sequences of characters.

\sphinxAtStartPar
Python accepts either single or double quotes to represent strings:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hello}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}Hello\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Hello}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}Hello\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Sam says, }\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{jump!}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}Sam says, \PYGZdq{}jump!\PYGZdq{}\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Even triple quotes are accepted:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Triple}
\PYG{l+s+sd}{quotes}
\PYG{l+s+sd}{allow}
\PYG{l+s+sd}{multi}
\PYG{l+s+sd}{line\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}Triple\PYGZbs{}nquotes\PYGZbs{}nallow\PYGZbs{}nmulti\PYGZbs{}nline\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\textbackslash{}n}} is a special escape sequence that represents a linebreak (see more escape sequences: \sphinxurl{https://docs.python.org/3/reference/lexical\_analysis.html\#escape-sequences}).
If we print it out with \sphinxcode{\sphinxupquote{print}}, the linebreaks are displayed as actual linebreaks:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}\PYG{l+s+s2}{Triple}
\PYG{l+s+s2}{quotes}
\PYG{l+s+s2}{allow}
\PYG{l+s+s2}{multi}
\PYG{l+s+s2}{line}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Triple
quotes
allow
multi
line
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{str()}} coerces values to be a string.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{str}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.0}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}\PYGZhy{}5.0\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{str}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{l+m+mi}{3}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}4\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{str}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.0}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}\PYGZhy{}5.0\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{str}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mi}{3}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}4\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{23} \PYG{o}{/} \PYG{l+m+mi}{7}
\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}3.2857142857142856\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Concatenation}
\label{\detokenize{datatypes:concatenation}}
\sphinxAtStartPar
String expression can be combined to form a new longer string expression.
This is done through the operation concatenation (\sphinxcode{\sphinxupquote{+}}).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hello}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ }\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{world}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}Hello world\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Replication}
\label{\detokenize{datatypes:replication}}
\sphinxAtStartPar
Python strings support the \sphinxcode{\sphinxupquote{*}} operator though.
This multiplies strings to repeat them:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hello}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{*}\PYG{l+m+mi}{3}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}HelloHelloHello\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{5}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{,000}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{*} \PYG{l+m+mi}{3}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}5,000,000,000\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{A}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{*} \PYG{l+m+mi}{10}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}AAAAAAAAAA\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Boolean type}
\label{\detokenize{datatypes:boolean-type}}
\sphinxAtStartPar
This is a value to represent true and false values.

\sphinxAtStartPar
In Python, we use the keywords \sphinxcode{\sphinxupquote{True}} and \sphinxcode{\sphinxupquote{False}}:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kc}{True}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kc}{False}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
False
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Boolean operators}
\label{\detokenize{datatypes:boolean-operators}}
\sphinxAtStartPar
We can combine boolean expressions using the operators \sphinxcode{\sphinxupquote{and}}, \sphinxcode{\sphinxupquote{or}}, \sphinxcode{\sphinxupquote{not}}.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{and}}:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kc}{True} \PYG{o+ow}{and} \PYG{k+kc}{True}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kc}{True} \PYG{o+ow}{and} \PYG{k+kc}{False}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
False
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{or}}:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kc}{True} \PYG{o+ow}{or} \PYG{k+kc}{True}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kc}{True} \PYG{o+ow}{or} \PYG{k+kc}{False}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{not}}:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o+ow}{not} \PYG{k+kc}{True}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
False
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o+ow}{not} \PYG{k+kc}{False}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{Compound Boolean}
\label{\detokenize{datatypes:compound-boolean}}
\sphinxAtStartPar
And just like any expression we can combine boolean expression into compound expressions

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{k+kc}{True} \PYG{o+ow}{and} \PYG{k+kc}{True}\PYG{p}{)} \PYG{o+ow}{and} \PYG{p}{(}\PYG{k+kc}{True} \PYG{o+ow}{and} \PYG{k+kc}{False}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
False
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{k+kc}{True}
\PYG{n}{y} \PYG{o}{=} \PYG{k+kc}{False}
\PYG{n}{x} \PYG{o+ow}{or} \PYG{p}{(}\PYG{o+ow}{not} \PYG{n}{y}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{Truth table}
\label{\detokenize{datatypes:truth-table}}
\sphinxAtStartPar
Refer to the truth table below to see how operators behave


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
and
&\sphinxstyletheadfamily 
\sphinxAtStartPar
left operand
&\sphinxstyletheadfamily 
\sphinxAtStartPar
right operand
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxstylestrong{True}
&
\sphinxAtStartPar
True
&
\sphinxAtStartPar
False
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{False}
&
\sphinxAtStartPar
False
&
\sphinxAtStartPar
False
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
or
&\sphinxstyletheadfamily 
\sphinxAtStartPar
left operand
&\sphinxstyletheadfamily 
\sphinxAtStartPar
right operan
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxstylestrong{True}
&
\sphinxAtStartPar
True
&
\sphinxAtStartPar
True
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{False}
&
\sphinxAtStartPar
True
&
\sphinxAtStartPar
False
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\section{Sequence type}
\label{\detokenize{datatypes:sequence-type}}
\sphinxAtStartPar
A sequence type is used to store multiple values a collective structure. There are multiple sequence datatypes in python: Lists, tuples, and dicts


\subsection{Lists}
\label{\detokenize{datatypes:lists}}
\sphinxAtStartPar
For Python, the basic type for sequences is the \sphinxcode{\sphinxupquote{list}}.
List literals are created with square brackets, \sphinxcode{\sphinxupquote{{[}{]}}}.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{k+kc}{True}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{five}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[1, 2, 3, True, \PYGZsq{}five\PYGZsq{}]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[5, 0]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
The list \sphinxcode{\sphinxupquote{{[}1,2,3,True,'five'{]}}} is a list containing the expressions, \sphinxcode{\sphinxupquote{1}},\sphinxcode{\sphinxupquote{2}},\sphinxcode{\sphinxupquote{3}}, True, \sphinxcode{\sphinxupquote{'five'}}. The expressions in a list are known as its \sphinxstylestrong{elements}. The list \sphinxcode{\sphinxupquote{{[}5,0{]}}} is a list containing the elements \sphinxcode{\sphinxupquote{5}} and \sphinxcode{\sphinxupquote{0}}. The list \sphinxcode{\sphinxupquote{{[}{]}}} is an empty list. An empty list is a list that doesnt have any elements inside of it.

\sphinxAtStartPar
As we can see, the elements inside a list can be expressions of any datatype. And since lists are expressions themselves, we can also put lists inside lists.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[[1, 2, 3, [4]], [], [5, 6]]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Note that while lists can contain a mix of different expression types, it is generally not advisable to create a mixed list. Lists and sequences in general are interacted with as a collective. A mixed collective of different types can result in unexpected behavior and type incompatiblilty.


\subsection{Inserting items}
\label{\detokenize{datatypes:inserting-items}}
\sphinxAtStartPar
A lists contents can be changed using append and delete statements. Appending to list means adding an element at the end.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{items} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Apple}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Banana}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Cherry}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\PYG{n}{items}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Durian}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{items}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[\PYGZsq{}Apple\PYGZsq{}, \PYGZsq{}Banana\PYGZsq{}, \PYGZsq{}Cherry\PYGZsq{}, \PYGZsq{}Durian\PYGZsq{}]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Items can also be inserted in arbitrary positions within a list

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{items}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Orange}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{items}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[\PYGZsq{}Apple\PYGZsq{}, \PYGZsq{}Banana\PYGZsq{}, \PYGZsq{}Orange\PYGZsq{}, \PYGZsq{}Cherry\PYGZsq{}, \PYGZsq{}Durian\PYGZsq{}]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Using \sphinxcode{\sphinxupquote{items.insert(2,"Orange")}}, inserts an item in position 2 of the list
\begin{quote}

\sphinxAtStartPar
Note how the value of the list variable \sphinxcode{\sphinxupquote{items}} was modified after using \sphinxcode{\sphinxupquote{append}} and insert
\end{quote}


\subsection{Retrieving items}
\label{\detokenize{datatypes:retrieving-items}}
\sphinxAtStartPar
We can retrieve items from a list using list indexing. An indexing expression retrieves an element of a list at a specified position.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{items}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}Apple\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{items}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}Orange\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{3}
\PYG{n}{items}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}Cherry\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{items}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}Orange\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Indexing with \sphinxcode{\sphinxupquote{items{[}0{]}}} evaluates into the element at position \sphinxcode{\sphinxupquote{0}} of \sphinxcode{\sphinxupquote{items}}. Note that lists and other python sequences start at position 0. The first item is located at position 0 (also known as index 0) and the last item is located at position size\sphinxhyphen{}1 (also known as index size\sphinxhyphen{}1)


\subsection{Updating items}
\label{\detokenize{datatypes:updating-items}}
\sphinxAtStartPar
We can also modify a list by reassigning the value of a specific element.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{items} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Apple}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Banana}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Cherry}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\PYG{n}{items}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Strawberry}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{items}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[\PYGZsq{}Apple\PYGZsq{}, \PYGZsq{}Banana\PYGZsq{}, \PYGZsq{}Strawberry\PYGZsq{}]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Running the cell above will overwrite the element at position 2/index 2 of the list. In this case, ‘Orange’ is overwritten into ‘Strawberry’


\subsection{Deleting items}
\label{\detokenize{datatypes:deleting-items}}
\sphinxAtStartPar
To remove an item from the list, we have \sphinxcode{\sphinxupquote{del}} and \sphinxcode{\sphinxupquote{.remove()}}.

\sphinxAtStartPar
To remove an item based on a given index, use \sphinxcode{\sphinxupquote{del}}:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{items} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Apple}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Banana}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Cherry}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\PYG{k}{del} \PYG{n}{items}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{items}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[\PYGZsq{}Apple\PYGZsq{}, \PYGZsq{}Cherry\PYGZsq{}]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
In the case above, the element at index 1, is \sphinxcode{\sphinxupquote{Banana}}. Running \sphinxcode{\sphinxupquote{del items{[}1{]}}} deletes the element at index 1 which is \sphinxcode{\sphinxupquote{Banana}}. When we evaluate items again we see that \sphinxcode{\sphinxupquote{Banana}} is deleted from \sphinxcode{\sphinxupquote{items}}

\sphinxAtStartPar
We can also delete items based on value. This is done througn the remove function. This function removes the first item that matches the the specified value

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{items} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Apple}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Cherry}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Banana}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Cherry}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{items}\PYG{o}{.}\PYG{n}{remove}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Cherry}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{items}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[\PYGZsq{}Apple\PYGZsq{}, \PYGZsq{}Banana\PYGZsq{}, \PYGZsq{}Cherry\PYGZsq{}]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Note how the second instance \sphinxcode{\sphinxupquote{'Cherry'}} is not deleted since \sphinxcode{\sphinxupquote{remove}} only deletes the first match.


\subsection{Length}
\label{\detokenize{datatypes:length}}
\sphinxAtStartPar
You can check the length/size of a list using \sphinxcode{\sphinxupquote{len()}}. Using it on a list will evaluate to an integer that represents the number of elements in said list.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{len}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
4
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{len}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
1
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{items}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
3
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Concatenation}
\label{\detokenize{datatypes:id1}}
\sphinxAtStartPar
You can concatenate 2 list expressions together to form a new list. The process works similarly as string concatenation. It will evaluate into a new list where the elements of the right operand is attached to the end of the left operand

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{o}{+} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[1, 2, 3, 4, 5]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{items1} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Apple}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Banana}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Cherry}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{items2} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Durian}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{items1} \PYG{o}{+} \PYG{n}{items2}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[\PYGZsq{}Apple\PYGZsq{}, \PYGZsq{}Banana\PYGZsq{}, \PYGZsq{}Cherry\PYGZsq{}, \PYGZsq{}Durian\PYGZsq{}]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Unlike \sphinxcode{\sphinxupquote{append()}}, using concatenation does not change the values of the original list. The concatenation expression evaluates into a new combined list

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{items1}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[\PYGZsq{}Apple\PYGZsq{}, \PYGZsq{}Banana\PYGZsq{}, \PYGZsq{}Cherry\PYGZsq{}]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{items2}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[\PYGZsq{}Durian\PYGZsq{}]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Tuples}
\label{\detokenize{datatypes:tuples}}
\sphinxAtStartPar
Python tuples are just like the Python list, except that they are \sphinxstylestrong{immutable}. That is, they are lists that cannot be modified after creation.

\sphinxAtStartPar
We can create a tuple by separating values with a \sphinxcode{\sphinxupquote{,}}:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(1, 2)
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}\begin{quote}

\sphinxAtStartPar
Python represents tuples as parentheses. You can also use parentheses on your tuples to make it more readable
\end{quote}

\sphinxAtStartPar
Reviewing the list operations discussed above, we can use operations on tuples that do not result in some form of modification. Retrieval, length, and concatenation are allowed

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{coords} \PYG{o}{=} \PYG{l+m+mf}{3.1}\PYG{p}{,}\PYG{l+m+mf}{1.2}
\PYG{n}{coords}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
1.2
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{coords}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
2
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{coords} \PYG{o}{+} \PYG{p}{(}\PYG{l+m+mf}{2.1}\PYG{p}{,}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(3.1, 1.2, 2.1)
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}\begin{quote}

\sphinxAtStartPar
The expression \sphinxcode{\sphinxupquote{(2.1,)}} is evaluated as a tuple with one element. Just writing \sphinxcode{\sphinxupquote{2.1}} will evaluate into a float
\end{quote}

\sphinxAtStartPar
Appending, deletion, removal, and insertion are not allowed

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{coords}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mf}{4.0}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{AttributeError}\PYG{g+gWhitespace}{                            }Traceback (most recent call last)
\PYG{n}{Cell} \PYG{n}{In}\PYG{p}{[}\PYG{l+m+mi}{57}\PYG{p}{]}\PYG{p}{,} \PYG{n}{line} \PYG{l+m+mi}{1}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{1} \PYG{n}{coords}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mf}{4.0}\PYG{p}{)}

\PYG{n+ne}{AttributeError}: \PYGZsq{}tuple\PYGZsq{} object has no attribute \PYGZsq{}append\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{del} \PYG{n}{coords}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{TypeError}\PYG{g+gWhitespace}{                                 }Traceback (most recent call last)
\PYG{n}{Cell} \PYG{n}{In}\PYG{p}{[}\PYG{l+m+mi}{59}\PYG{p}{]}\PYG{p}{,} \PYG{n}{line} \PYG{l+m+mi}{1}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{1} \PYG{k}{del} \PYG{n}{coords}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}

\PYG{n+ne}{TypeError}: \PYGZsq{}tuple\PYGZsq{} object doesn\PYGZsq{}t support item deletion
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{coords}\PYG{o}{.}\PYG{n}{remove}\PYG{p}{(}\PYG{l+m+mf}{2.1}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{AttributeError}\PYG{g+gWhitespace}{                            }Traceback (most recent call last)
\PYG{n}{Cell} \PYG{n}{In}\PYG{p}{[}\PYG{l+m+mi}{60}\PYG{p}{]}\PYG{p}{,} \PYG{n}{line} \PYG{l+m+mi}{1}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{1} \PYG{n}{coords}\PYG{o}{.}\PYG{n}{remove}\PYG{p}{(}\PYG{l+m+mf}{2.1}\PYG{p}{)}

\PYG{n+ne}{AttributeError}: \PYGZsq{}tuple\PYGZsq{} object has no attribute \PYGZsq{}remove\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{coords}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mf}{0.1}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{AttributeError}\PYG{g+gWhitespace}{                            }Traceback (most recent call last)
\PYG{n}{Cell} \PYG{n}{In}\PYG{p}{[}\PYG{l+m+mi}{61}\PYG{p}{]}\PYG{p}{,} \PYG{n}{line} \PYG{l+m+mi}{1}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{1} \PYG{n}{coords}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mf}{0.1}\PYG{p}{)}

\PYG{n+ne}{AttributeError}: \PYGZsq{}tuple\PYGZsq{} object has no attribute \PYGZsq{}insert\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Strings as tuples}
\label{\detokenize{datatypes:strings-as-tuples}}
\sphinxAtStartPar
As is turns out, string expressions are similar to tuples of characters. You can interact with a string expression just like you will any tuple expression. Just keep in mind that the elements of a string can only be single characters.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{word} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{snakes}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{word}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}a\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{word}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
6
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Packing and unpacking}
\label{\detokenize{datatypes:packing-and-unpacking}}
\sphinxAtStartPar
We’ve already seen what’s called \sphinxstyleemphasis{tuple packing}.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{coords} \PYG{o}{=} \PYG{l+m+mf}{2.1}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.0}
\PYG{n}{coords}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(2.1, 0.3, \PYGZhy{}5.0)
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
The above statement packs the 3 values together down into a tuple and then assigns it to \sphinxcode{\sphinxupquote{coords}}.

\sphinxAtStartPar
The reverse is also possible, called \sphinxstyleemphasis{sequence unpacking}.

\sphinxAtStartPar
Here’s an example of a sequence unpack:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x}\PYG{p}{,}\PYG{n}{y} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mf}{2.5}\PYG{p}{,}\PYG{l+m+mf}{13.1}\PYG{p}{)}
\PYG{n}{x}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
2.5
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{y}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
13.1
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a}\PYG{p}{,}\PYG{n}{b}\PYG{p}{,}\PYG{n}{c} \PYG{o}{=} \PYG{n}{coords}
\PYG{n}{a}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
2.1
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
The tuple on the right\sphinxhyphen{}hand side is unpacked and assigned into the variables \sphinxcode{\sphinxupquote{x}} and \sphinxcode{\sphinxupquote{y}}.
\sphinxcode{\sphinxupquote{x}} gets assigned \sphinxcode{\sphinxupquote{2.5}} and \sphinxcode{\sphinxupquote{y}} is assigned \sphinxcode{\sphinxupquote{13.1}}.

\sphinxAtStartPar
Sequence unpacking requires the correct number of left\sphinxhyphen{}hand side variables to the number of right\sphinxhyphen{}hand side items.

\sphinxAtStartPar
Note that it’s called \sphinxstyleemphasis{sequence} unpacking.
This means it also works for other sequences, such as lists and even \sphinxcode{\sphinxupquote{str}}.


\section{Dictionaries}
\label{\detokenize{datatypes:dictionaries}}
\sphinxAtStartPar
Dictionaries allow us to map almost arbitrary keys to values.
For now, we can think of dictionaries as lists that allow us to “index” by a key. Unlike lists these keys do not have to be integers, it can be any hashable%
\begin{footnote}[1]\sphinxAtStartFootnote
\sphinxurl{https://docs.python.org/3/glossary.html\#term-hashable}
%
\end{footnote} expression.
\begin{quote}

\sphinxAtStartPar
Hashable values are values that are immutable, such as \sphinxcode{\sphinxupquote{int}}, \sphinxcode{\sphinxupquote{float}}, \sphinxcode{\sphinxupquote{str}}, and other types that at least implement the \sphinxcode{\sphinxupquote{\_\_hash\_\_()}} method.
\end{quote}

\sphinxAtStartPar
Dictionaries are created with \sphinxcode{\sphinxupquote{\{\}}}.
Each key\sphinxhyphen{}value entry of the dictionary is separated by a \sphinxcode{\sphinxupquote{:}}, with the key on the left and its value to the right.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{one}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{two}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{three}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{four}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZob{}\PYGZsq{}one\PYGZsq{}: 1, \PYGZsq{}two\PYGZsq{}: 2, \PYGZsq{}three\PYGZsq{}: 3, \PYGZsq{}four\PYGZsq{}: 4\PYGZcb{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
In the dictionary above, we use the string expression \sphinxcode{\sphinxupquote{"one"}} as the key for the value \sphinxcode{\sphinxupquote{1}}, \sphinxcode{\sphinxupquote{"two"}} as the key for the value \sphinxcode{\sphinxupquote{2}}, and so on. Similar to lists, tuples, and strings, we can retrieve values by indexing using the keys

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{data} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{name}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Fish}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{quantity}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{price}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{412.25}\PYG{p}{\PYGZcb{}}
\PYG{n}{data}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{name}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}Fish\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{key} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{price}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{data}\PYG{p}{[}\PYG{n}{key}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
412.25
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
The expression \sphinxcode{\sphinxupquote{data{[}"name"{]}}} retrieves the item associated to the key \sphinxcode{\sphinxupquote{"name"}}, which in this case is \sphinxcode{\sphinxupquote{"Fish"}}.

\sphinxAtStartPar
Adding an entry to the dictionary is also done by first retrieving an item using indexing and assigning a value to it.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{data}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{date}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2 Feb 2024}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{data}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZob{}\PYGZsq{}name\PYGZsq{}: \PYGZsq{}Fish\PYGZsq{}, \PYGZsq{}quantity\PYGZsq{}: 3, \PYGZsq{}price\PYGZsq{}: 412.25, \PYGZsq{}date\PYGZsq{}: \PYGZsq{}2 Feb 2024\PYGZsq{}\PYGZcb{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Updating is done the exact same way, but this time we retrieve an already existing entry and then reassigning a new value to it:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{data}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{price}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
412.25
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{data}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{price}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{450.00}
\PYG{n}{data}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZob{}\PYGZsq{}name\PYGZsq{}: \PYGZsq{}Fish\PYGZsq{}, \PYGZsq{}quantity\PYGZsq{}: 3, \PYGZsq{}price\PYGZsq{}: 450.0, \PYGZsq{}date\PYGZsq{}: \PYGZsq{}2 Feb 2024\PYGZsq{}\PYGZcb{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{data}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{price}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
450.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Deleting a key is done with \sphinxcode{\sphinxupquote{del}}:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{del} \PYG{n}{data}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{date}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\PYG{n}{data}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZob{}\PYGZsq{}name\PYGZsq{}: \PYGZsq{}Fish\PYGZsq{}, \PYGZsq{}quantity\PYGZsq{}: 3, \PYGZsq{}price\PYGZsq{}: 450.0\PYGZcb{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{data}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{date}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{KeyError}\PYG{g+gWhitespace}{                                  }Traceback (most recent call last)
\PYG{n}{Cell} \PYG{n}{In}\PYG{p}{[}\PYG{l+m+mi}{77}\PYG{p}{]}\PYG{p}{,} \PYG{n}{line} \PYG{l+m+mi}{1}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{1} \PYG{n}{data}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{date}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}

\PYG{n+ne}{KeyError}: \PYGZsq{}date\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}\begin{quote}

\sphinxAtStartPar
Now that the entry associated to \sphinxcode{\sphinxupquote{"date"}} is now delete. Trying to retrieve it through indexing will cause a KeyError
\end{quote}


\section{Type compatibility}
\label{\detokenize{datatypes:type-compatibility}}
\sphinxAtStartPar
When it comes to expressions with operations, we must take into account if the operation is compatible with the dataype of the operands and vice versa. For example, we can expect that the addition operation (\sphinxcode{\sphinxupquote{+}}) is compatible with numeric types.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mi}{2}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
3
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{2.0} \PYG{o}{+} \PYG{l+m+mf}{1.1}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
3.1
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mf}{2.2}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
3.2
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Some operation\sphinxhyphen{}operand combinations are not compatible, an example of this is discussed earlier, strings and (\sphinxcode{\sphinxupquote{\sphinxhyphen{}}})

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abc}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZhy{}} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{TypeError}\PYG{g+gWhitespace}{                                 }Traceback (most recent call last)
\PYG{n}{Cell} \PYG{n}{In}\PYG{p}{[}\PYG{l+m+mi}{81}\PYG{p}{]}\PYG{p}{,} \PYG{n}{line} \PYG{l+m+mi}{1}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{1} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{abc}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZhy{}} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{n+ne}{TypeError}: unsupported operand type(s) for \PYGZhy{}: \PYGZsq{}str\PYGZsq{} and \PYGZsq{}str\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Trying to evaluate incompatibile expressions will cause a \sphinxcode{\sphinxupquote{TypeError}} as seen above

\sphinxAtStartPar
Sometimes you might expect values to be compatible but they are actually not

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{123}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{l+m+mi}{4}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{TypeError}\PYG{g+gWhitespace}{                                 }Traceback (most recent call last)
\PYG{n}{Cell} \PYG{n}{In}\PYG{p}{[}\PYG{l+m+mi}{82}\PYG{p}{]}\PYG{p}{,} \PYG{n}{line} \PYG{l+m+mi}{1}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{1} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{123}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{l+m+mi}{4}

\PYG{n+ne}{TypeError}: can only concatenate str (not \PYGZdq{}int\PYGZdq{}) to str
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
In cases like this if you concatenate the two expression, you must expliciltly apply the necessary coercions

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{123}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}1234\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Or if you were intending to add

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{int}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{123}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{4}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
127
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
In some cases, you migh expect types to be incompatible but in fact they actually are

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kc}{True} \PYG{o}{+} \PYG{k+kc}{True}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
2
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}\begin{quote}

\sphinxAtStartPar
When using numeric operations, python coerces booleans into their integer representations. \sphinxcode{\sphinxupquote{True}} is coerced into \sphinxcode{\sphinxupquote{1}} and \sphinxcode{\sphinxupquote{False}} is coerced into 0
\end{quote}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{k+kc}{True} \PYG{o}{*} \PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{+} \PYG{k+kc}{False}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
3
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\bigskip\hrule\bigskip


\sphinxstepscope


\chapter{First program}
\label{\detokenize{first-program:first-program}}\label{\detokenize{first-program::doc}}
\sphinxAtStartPar
The interpreter is handy for when we want to have Python calculate a few simple expressions, but it can get hard to use when we want to build programs out of it.

\sphinxAtStartPar
A Python program is simply a file containing Python expressions and instructions, which Python will execute.
The program can be as simple as one print statement:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hello world!}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Hello world!
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{subject} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Sam}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{verb} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{eats}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n+nb}{object} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{the apple}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{subject} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ }\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{verb} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ }\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{object} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Sam eats the apple.
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
The function \sphinxcode{\sphinxupquote{print()}} allows us to write string expressions in the output. This is commonly called as \sphinxstyleemphasis{printing}. In the case of jupyter, the string expression will be printed in the output section of the cell. On the case of python programs, the string expression will be be printed in the terminal. To demonstrate this lets create our first python program


\section{Writing your first program}
\label{\detokenize{first-program:writing-your-first-program}}
\sphinxAtStartPar
To start writing our Python program, we’ll have to open up a new file in a text editor.

\sphinxAtStartPar
Use any text editor (e.g. VS Code, Sublime Text, etc.) or Python IDE (e.g. PyCharm) that you’re comfortable with.
And while it’s completely not necessary for Python to have a full\sphinxhyphen{}fledged IDE, it can be quite a help.

\sphinxAtStartPar
Python is very strict with whitespaces and indentation as these are used to delineate sections of our program.
In fact, random indentations in the source code is an error—they mean something!
As such, if you can, set your text editor to interpret pressing the \sphinxcode{\sphinxupquote{<Tab>}} key as inserting 4 spaces instead of an actual \sphinxcode{\sphinxupquote{<Tab>}} character.
We don’t want to accidently mix in \sphinxcode{\sphinxupquote{<Tab>}}s and \sphinxcode{\sphinxupquote{<Space>}}s in our source file later on.

\sphinxAtStartPar
Now, write our little program.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hello world!}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxincludegraphics{{python_program}.png}
\begin{quote}

\sphinxAtStartPar
For this to run correctly, make sure you run the command at the same directory as \sphinxcode{\sphinxupquote{hello.py}}
\end{quote}

\sphinxAtStartPar
Save the file with the file extension \sphinxcode{\sphinxupquote{.py}}.
The \sphinxcode{\sphinxupquote{.py}} indicates that the file is a Python program.
In this case, let’s save it as \sphinxcode{\sphinxupquote{hello.py}}.


\section{Running our program}
\label{\detokenize{first-program:running-our-program}}
\sphinxAtStartPar
To run our program, we’ll use \sphinxcode{\sphinxupquote{python}} directly via a terminal (if you installed python through anaconda, you can use the anaconda prompt as your terminal). Make sure you run the command on the same directory the file \sphinxcode{\sphinxupquote{hello.py}} is in. If python is installed correctly and if there are no errors in your program, you should see the following output:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }python\PYG{+w}{ }hello.py
Hello\PYG{+w}{ }world!
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxincludegraphics{{python_program_output}.png}

\sphinxAtStartPar
Python will execute the file a line at a time.
When no more lines are left to execute, the Python program finishes and stops.


\section{Asking for user input}
\label{\detokenize{first-program:asking-for-user-input}}
\sphinxAtStartPar
To make our program more useful, we want it to accept user input.
Instead of computing the same numbers over and over again, or having to edit the source code, we can ask for user input with \sphinxcode{\sphinxupquote{input()}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{What}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{s your name?}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{name} \PYG{o}{=} \PYG{n+nb}{input}\PYG{p}{(}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hello, }\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{name}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
What\PYGZsq{}s your name?
Sam
Hello, Sam
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{input()}} will always try to evaluate user input into a \sphinxcode{\sphinxupquote{str}} literal, so  we’ll have to first coerce it to the appropriate datatype. Without the coercion you will encounter a type error due to type incompatibility. Remember this as it’s an easy error to miss.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{num} \PYG{o}{=} \PYG{n+nb}{input}\PYG{p}{(}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{num} \PYG{o}{+} \PYG{l+m+mi}{10}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Traceback (most recent call last):
  File \PYGZdq{}/home/user/program.py\PYGZdq{}, line 2, in \PYGZlt{}module\PYGZgt{}
    print(num + 10)
          \PYGZti{}\PYGZti{}\PYGZti{}\PYGZti{}\PYGZca{}\PYGZti{}\PYGZti{}\PYGZti{}
TypeError: can only concatenate str (not \PYGZdq{}int\PYGZdq{}) to str
\end{sphinxVerbatim}

\sphinxAtStartPar
In this case we are trying to add two numbers. So we coerce, \sphinxcode{\sphinxupquote{num}} into an integer first.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{num} \PYG{o}{=} \PYG{n+nb}{input}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{num} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{num}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{num} \PYG{o}{+} \PYG{l+m+mi}{10}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
25
35
\end{sphinxVerbatim}

\sphinxAtStartPar
Here’s another variant of this error:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Enter a number}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{num} \PYG{o}{=} \PYG{n+nb}{input}\PYG{p}{(}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{num} \PYG{o}{*} \PYG{l+m+mi}{5}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Enter a number
25
2525252525
\end{sphinxVerbatim}

\sphinxAtStartPar
Python will not crash from this because the \sphinxcode{\sphinxupquote{*}} operation is type compatible in this context. In this case it will be interpreted as a string replication, repeating \sphinxcode{\sphinxupquote{num}} 5 times.


\section{Writing comments}
\label{\detokenize{first-program:writing-comments}}
\sphinxAtStartPar
It is a good idea to write comments in your source code.
This serves as notes for the programmer (you, or other people) in the future.

\sphinxAtStartPar
We can write comments using the \sphinxcode{\sphinxupquote{\#}} character.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} This is a comment.}
\end{sphinxVerbatim}

\sphinxAtStartPar
Comments are ignored by Python when executing and they can even appear after Python expressions.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{num} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mi}{1} \PYG{c+c1}{\PYGZsh{} add 1 and 1 together}
\end{sphinxVerbatim}

\sphinxstepscope


\chapter{Conditionals}
\label{\detokenize{conditionals:conditionals}}\label{\detokenize{conditionals::doc}}
\sphinxAtStartPar
To enable our program to adapt and be more useful, we have to make use of control flow statements and conditionals.

\sphinxAtStartPar
In a flowchart, conditionals are blocks that allow the execution to split off into another branch depending on certain values.
This allows a flowchart to be more useful and be applicable to a variety of scenarios.

\sphinxAtStartPar
In the same way, we want our program to be useful and applicable to a variety of scenarios as well.

\sphinxAtStartPar
In Python, we have a few statements related to conditionals: \sphinxcode{\sphinxupquote{if}}, \sphinxcode{\sphinxupquote{else}}, and \sphinxcode{\sphinxupquote{elif}}.


\section{\sphinxstyleliteralintitle{\sphinxupquote{if}}}
\label{\detokenize{conditionals:if}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{if}} statement is a conditional that defines that a block of code is to be executed if the condition is true; otherwise, it is skipped.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{k+kc}{True}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hey, it}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{s true!}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{k}{if} \PYG{k+kc}{False}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{This is false, it won}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{t print.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Hey, it\PYGZsq{}s true!
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Note that the indentation here is important.
It determines whether the code falls under the \sphinxcode{\sphinxupquote{if}} statement or not.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{k+kc}{False}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Not printing}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{I}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{m outside of the if so I get printed}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
I\PYGZsq{}m outside of the if so I get printed
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
As with much of programming, we can compound the condition and nest it:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{k+kc}{True}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{This is printing}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{if} \PYG{k+kc}{False}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{But not this}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{if} \PYG{k+kc}{False}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{None of this either}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{if} \PYG{k+kc}{True}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Nor this}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
This is printing
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Of course, we wouldn’t be checking if \sphinxcode{\sphinxupquote{True}} is true or \sphinxcode{\sphinxupquote{False}} is false in a real program.
Most likely, we’d have a variable or a condition instead of a literal.
\begin{quote}

\sphinxAtStartPar
Notice the indentation of the last two lines of code, the last two lines are all inside the \sphinxcode{\sphinxupquote{if False}} block. To indicate this we add one more level of indentation to every line in the block
\end{quote}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{num} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{k}{if} \PYG{n}{num} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{60}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{High}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{if} \PYG{n}{num} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{60}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Low}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Low
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Depending on the value of \sphinxcode{\sphinxupquote{num}} provided, we’d get an output of \sphinxcode{\sphinxupquote{High}} or \sphinxcode{\sphinxupquote{Low}}.

\sphinxAtStartPar
The expression \sphinxcode{\sphinxupquote{num > 60}} either evaluates to \sphinxcode{\sphinxupquote{True}}, which will tell Python to proceed with the clause under the first \sphinxcode{\sphinxupquote{if}} statement, or \sphinxcode{\sphinxupquote{num <= 60}} is true, telling Python to print \sphinxcode{\sphinxupquote{Low}}.

\sphinxAtStartPar
This either\sphinxhyphen{}or pattern is common enough that we have a construct for that.


\section{\sphinxstyleliteralintitle{\sphinxupquote{else}}}
\label{\detokenize{conditionals:else}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{if}} statement may have an optional \sphinxcode{\sphinxupquote{else}} statement after it, implementing the either\sphinxhyphen{}or pattern.

\sphinxAtStartPar
In an \sphinxcode{\sphinxupquote{if\sphinxhyphen{}else}} statement, only one block of the two is executed.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{k+kc}{True}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Only this}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{and not this}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Only this
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{num} \PYG{o}{=} \PYG{l+m+mi}{90}
\PYG{k}{if} \PYG{n}{num} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{60}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{High}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Low}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
High
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}\begin{quote}

\sphinxAtStartPar
Using \sphinxcode{\sphinxupquote{else}} without an \sphinxcode{\sphinxupquote{if}} is a syntax error.
\end{quote}

\sphinxAtStartPar
Creating \sphinxcode{\sphinxupquote{if\sphinxhyphen{}else}} blocks, allows us to split the program into two branches. If we are looking for more than two we can compound \sphinxcode{\sphinxupquote{if\sphinxhyphen{}else}} statements inside other \sphinxcode{\sphinxupquote{if}} or \sphinxcode{\sphinxupquote{else}} statements.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{num} \PYG{o}{=} \PYG{l+m+mi}{24}
\PYG{k}{if} \PYG{n}{num} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{60}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{High}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{num} \PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{l+m+mi}{60} \PYG{o+ow}{and} \PYG{n}{num} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{40}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Medium}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Low}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Low
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
In the code above, the program can go in either three branches, if the inputted number is greater than 60, it goes to the first branch and prints “High”, if the inputted number is 60 or lesser but greater than 40, it goes to the 2nd branch. If it is not greater than 60, or if it is not between 40 and 60, it goes to the third branch. The third branch in this case is the \sphinxcode{\sphinxupquote{else}} branch of the \sphinxcode{\sphinxupquote{else}} branch.
\begin{quote}

\sphinxAtStartPar
Notice the indentation of the last four lines of code, the last four lines are all inside the \sphinxcode{\sphinxupquote{else}} block. To indicate this we add one more level of indentation to the every line in the block
\end{quote}

\sphinxAtStartPar
You can write write three branches neatly using the \sphinxcode{\sphinxupquote{elif}} block. \sphinxcode{\sphinxupquote{elif}} is short for \sphinxcode{\sphinxupquote{else\sphinxhyphen{}if}} and it acts like a combination of an \sphinxcode{\sphinxupquote{else}} block and an \sphinxcode{\sphinxupquote{if}} block. Using the \sphinxcode{\sphinxupquote{elif}} block we can write a more readable program equivalent to the previous program.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{num} \PYG{o}{=} \PYG{l+m+mi}{45}
\PYG{k}{if} \PYG{n}{num} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{60}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{High}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{elif} \PYG{n}{num} \PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{l+m+mi}{60} \PYG{o+ow}{and} \PYG{n}{num} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{40}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Medium}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Low}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Medium
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\chapter{Loops}
\label{\detokenize{loops:loops}}\label{\detokenize{loops::doc}}
\sphinxAtStartPar
Imperative programs, such as python programs are built by combining code into three ways: chains, branches/selection, and loops/repetition. Chains are pretty simple. We’ve seen a few examples of it. It is simply executing lines of code one after the other. The example below is a chain of three lines of code:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{3}
\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{7}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x}\PYG{o}{+}\PYG{n}{y}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
10
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Branching/selection is also something we have discussed. We combine statements into branches using \sphinxcode{\sphinxupquote{if\sphinxhyphen{}else}} and \sphinxcode{\sphinxupquote{if\sphinxhyphen{}elif}} conditionals. The example below are two branches of code:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{password} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pword}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{password}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{7}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{password too weak}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{password accepted}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
password too weak
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
The third way of combining code is through loops/repetition. The name is self\sphinxhyphen{}explanatory. Repetition allows us to repeatedly run lines of code.

\sphinxAtStartPar
See the example below.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{k}{while} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{3}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{again}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{i} \PYG{o}{=} \PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{finish}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
again
again
again
finish
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
The code above repeatedly runs the last two lines 5 times.

\sphinxAtStartPar
Lets dissect the code line by line to understand how it works.

\sphinxAtStartPar
The first line \sphinxcode{\sphinxupquote{i=0}}, is simply an assignment statement that \sphinxstylestrong{initializes} the value of \sphinxcode{\sphinxupquote{i}} to \sphinxcode{\sphinxupquote{0}}.

\sphinxAtStartPar
The second line is known as a while statement. It is written similar to \sphinxcode{\sphinxupquote{if}} and \sphinxcode{\sphinxupquote{elif}} statements. It is the \sphinxcode{\sphinxupquote{while}} keyword followed by boolean expression (any expression that evaluates into a boolean type value). The boolean expression inside this \sphinxcode{\sphinxupquote{while}} statements is \sphinxcode{\sphinxupquote{i<3}}. Like the \sphinxcode{\sphinxupquote{if}}, \sphinxcode{\sphinxupquote{else}}, and \sphinxcode{\sphinxupquote{elif}} statements, we end the \sphinxcode{\sphinxupquote{while}} statement with a \sphinxcode{\sphinxupquote{:}} (colon)

\sphinxAtStartPar
The third line is a print statement, simply printing the string literal \sphinxcode{\sphinxupquote{again}}. The fourth line is another assignment statement. This statement reassigns the value of \sphinxcode{\sphinxupquote{i}} to \sphinxcode{\sphinxupquote{i+1}} (an increment statement, review assignment statements in the Expressions chapter). Notice how the third and fourth lines are indented. Again, indentation here is important. Changing the indentation will change the meaning of the program.

\sphinxAtStartPar
The fifth line is another print statement, this time without indentation. This line prints the string literal \sphinxcode{\sphinxupquote{'finish'}}.


\section{How python interprets the code}
\label{\detokenize{loops:how-python-interprets-the-code}}
\sphinxAtStartPar
Lets take a step by step discussion on how python interprets the cell above:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Starting from line 1, python assigns the variable \sphinxcode{\sphinxupquote{i}} with \sphinxcode{\sphinxupquote{0}}.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{On the second line, python checks if the boolean expression inside the while statement is true. In this case “Is \sphinxcode{\sphinxupquote{i < 3}}”? Yes it is. Since \sphinxcode{\sphinxupquote{0}} is less than 5, it proceeds to the indented lines.}
\begin{itemize}
\item {} 
\sphinxAtStartPar
It executes the third line, printing the string \sphinxcode{\sphinxupquote{'again'}}.

\item {} 
\sphinxAtStartPar
It executes the fourth line, overwriting the value of \sphinxcode{\sphinxupquote{i}} to \sphinxcode{\sphinxupquote{i+1}}. Since \sphinxcode{\sphinxupquote{i}} is zero before this line, the increment, will change the value of \sphinxcode{\sphinxupquote{i}} to \sphinxcode{\sphinxupquote{0+1}} or simply \sphinxcode{\sphinxupquote{1}}.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Instead of proceeding to the fifth line, python goes back to the the while statement, and checks again, “Is \sphinxcode{\sphinxupquote{i < 3}}? Since \sphinxcode{\sphinxupquote{1}} (the current value of \sphinxcode{\sphinxupquote{i}}) is still less than \sphinxcode{\sphinxupquote{3}}. The check is successful and it proceeds to the indented lines again}
\begin{itemize}
\item {} 
\sphinxAtStartPar
It executes the third line, printing the string \sphinxcode{\sphinxupquote{'again'}}.

\item {} 
\sphinxAtStartPar
It executes the fourth line, overwriting the value of \sphinxcode{\sphinxupquote{i}} to \sphinxcode{\sphinxupquote{i+1}}. Since \sphinxcode{\sphinxupquote{i}} is 1 before this line, the increment, will change the value to \sphinxcode{\sphinxupquote{i}} of \sphinxcode{\sphinxupquote{1+1}} or simply \sphinxcode{\sphinxupquote{2}}.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{python goes back to the the while statement, and checks again, “Is \sphinxcode{\sphinxupquote{i < 3}}? Since \sphinxcode{\sphinxupquote{2}} (the current value of \sphinxcode{\sphinxupquote{i}}) is still less than \sphinxcode{\sphinxupquote{3}}. The check is successful and it proceeds to the indented lines again}
\begin{itemize}
\item {} 
\sphinxAtStartPar
It executes the third line, printing the string \sphinxcode{\sphinxupquote{'again'}}.

\item {} 
\sphinxAtStartPar
It executes the fourth line, overwriting the value of \sphinxcode{\sphinxupquote{i}} to \sphinxcode{\sphinxupquote{i+1}}. Since \sphinxcode{\sphinxupquote{i}} is 1 before this line, the increment, will change the value to \sphinxcode{\sphinxupquote{i}} of \sphinxcode{\sphinxupquote{2+1}} or simply \sphinxcode{\sphinxupquote{3}}.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{python goes back to the the while statement, and checks again, “Is \sphinxcode{\sphinxupquote{i < 3}}? Since \sphinxcode{\sphinxupquote{3}} (the current value of \sphinxcode{\sphinxupquote{i}}) is not less than \sphinxcode{\sphinxupquote{3}}. The check fails. It skips the indented lines and proceeds to the fifth line}

\item {} 
\sphinxAtStartPar
It executes the fifth line and prints \sphinxcode{\sphinxupquote{'finish'}}

\end{itemize}

\sphinxAtStartPar
As you can see, the indented lines after the \sphinxcode{\sphinxupquote{while}} statement are repeated \sphinxstyleemphasis{while} the boolean expression remains true.

\sphinxAtStartPar
Let’s look at some more examples:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{countdown...}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{5}
\PYG{k}{while} \PYG{n}{i} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{...}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{i} \PYG{o}{=} \PYG{n}{i} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{lift off!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
countdown...
5...
4...
3...
2...
1...
0...
lift off!
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
As expected, the indented lines right after the \sphinxcode{\sphinxupquote{while}} statement are repeated until the boolean expresion \sphinxcode{\sphinxupquote{i >= 0}} evaluates to \sphinxcode{\sphinxupquote{False}}. In this case value of \sphinxcode{\sphinxupquote{i}} starts as 5 and during every repetition, it is reduced/decremented by 1. Until it becomes \sphinxcode{\sphinxupquote{\sphinxhyphen{}1}} which causes the boolean expression, \sphinxcode{\sphinxupquote{i >= 0}} to fail (i.e. evaluates to \sphinxcode{\sphinxupquote{False}}).

\sphinxAtStartPar
In this example we are repeatedly printing the concatenation of \sphinxcode{\sphinxupquote{str(i)}} (variable \sphinxcode{\sphinxupquote{i}} coerced as an \sphinxcode{\sphinxupquote{int}}), and \sphinxcode{\sphinxupquote{'...'}}. Because of this print statement we are seeing how the value of \sphinxcode{\sphinxupquote{i}} changes across every repetition.


\section{Lists and loops}
\label{\detokenize{loops:lists-and-loops}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fruits} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Apple}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Banana}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Cherry}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Durian}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{string\PYGZus{}of\PYGZus{}fruits} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k}{while} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{fruits}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{string\PYGZus{}of\PYGZus{}fruits} \PYG{o}{=} \PYG{n}{string\PYGZus{}of\PYGZus{}fruits} \PYG{o}{+} \PYG{n}{fruits}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{, }\PYG{l+s+s1}{\PYGZsq{}}
    \PYG{n}{i} \PYG{o}{=} \PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Here are the items: }\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n}{string\PYGZus{}of\PYGZus{}fruits}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Here are the items: Apple, Banana, Cherry, Durian, 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Here is a more complex example. We have a list containing strings called \sphinxcode{\sphinxupquote{fruits}}. And we have \sphinxcode{\sphinxupquote{i}} which starts as 0, and \sphinxcode{\sphinxupquote{string\_of\_fruits}} which starts as \sphinxcode{\sphinxupquote{''}} (an empty string, a string with no contents).

\sphinxAtStartPar
Our while loop has the boolean expression \sphinxcode{\sphinxupquote{i < len(fruits)}}. This expression basically checks if the variable \sphinxcode{\sphinxupquote{i}} is less than the length of the list \sphinxcode{\sphinxupquote{fruits}}.

\sphinxAtStartPar
The statements that get repeated are lines 5 and 6. Line 5 reassigns the variable \sphinxcode{\sphinxupquote{string\_of\_fruits}} with the concatenation \sphinxcode{\sphinxupquote{string\_of\_fruits + fruits{[}i{]} + ', '}}. This expression concatenates the current value of \sphinxcode{\sphinxupquote{string\_of\_fruits}} and \sphinxcode{\sphinxupquote{fruits{[}i{]}}}, which is the element of \sphinxcode{\sphinxupquote{fruits}} at position \sphinxcode{\sphinxupquote{i}}.

\sphinxAtStartPar
To see this clearer, lets print the value of \sphinxcode{\sphinxupquote{string\_of\_fruits}} at every repetition of the loop. I have added comments to show the print statements I have added.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fruits} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Apple}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Banana}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Cherry}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Durian}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{string\PYGZus{}of\PYGZus{}fruits} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{string\PYGZus{}of\PYGZus{}fruits}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}value of string\PYGZus{}of\PYGZus{}fruits before the while loop begins}
\PYG{k}{while} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{fruits}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{string\PYGZus{}of\PYGZus{}fruits} \PYG{o}{=} \PYG{n}{string\PYGZus{}of\PYGZus{}fruits} \PYG{o}{+} \PYG{n}{fruits}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{, }\PYG{l+s+s1}{\PYGZsq{}}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{string\PYGZus{}of\PYGZus{}fruits}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}value of string\PYGZus{}of\PYGZus{}fruits during every repetition (after reassignment)}
    \PYG{n}{i} \PYG{o}{=} \PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Here are the items: }\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n}{string\PYGZus{}of\PYGZus{}fruits}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Apple, 
Apple, Banana, 
Apple, Banana, Cherry, 
Apple, Banana, Cherry, Durian, 
Here are the items: Apple, Banana, Cherry, Durian, 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
As expected, before the loop \sphinxcode{\sphinxupquote{string\_of\_fruits}} is an empty string. You can see this as the blank line at the start of the output. On the first repetition \sphinxcode{\sphinxupquote{string\_of\_fruits}} gets updated by concatenating it with the \sphinxcode{\sphinxupquote{fruits{[}0{]}}} or the first element of the list \sphinxcode{\sphinxupquote{fruit}}. On the second repetition, \sphinxcode{\sphinxupquote{string\_of\_fruits}} gets updated again by concatenating it with \sphinxcode{\sphinxupquote{fruits{[}1{]}}}, or the second element of the \sphinxcode{\sphinxupquote{fruits}}. And so on, until the boolean expression \sphinxcode{\sphinxupquote{i < len(fruits)}} fails and the while loop stops.


\section{Branches inside loops}
\label{\detokenize{loops:branches-inside-loops}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{values} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}

\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{k}{while} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{values}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{values}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{3}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{values}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{i} \PYG{o}{=} \PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
7
6
6
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
In the example above we can see how we can put branches inside our while loops. Here we have an while loop that starts with \sphinxcode{\sphinxupquote{i}} as \sphinxcode{\sphinxupquote{0}}. It checks if \sphinxcode{\sphinxupquote{i < len(values)}}: While this is true it repeats the following:
It checks if the element at position \sphinxcode{\sphinxupquote{i}} is greater than 3. If it is, it prints the element. It then increments \sphinxcode{\sphinxupquote{i}} by one.


\section{Loops inside loops}
\label{\detokenize{loops:loops-inside-loops}}
\sphinxAtStartPar
We can also put loops inside loops, these are know as nested loops

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{k}{while} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{4}\PYG{p}{:}
    \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{k}{while} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{3}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{i=}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{, }\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{j=}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{j} \PYG{o}{=} \PYG{n}{j} \PYG{o}{+} \PYG{l+m+mi}{1}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} prints an empty line}
    \PYG{n}{i} \PYG{o}{=} \PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
i=0, j=0
i=0, j=1
i=0, j=2

i=1, j=0
i=1, j=1
i=1, j=2

i=2, j=0
i=2, j=1
i=2, j=2

i=3, j=0
i=3, j=1
i=3, j=2
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
The example above shows the values of \sphinxcode{\sphinxupquote{i}} and \sphinxcode{\sphinxupquote{j}} during every repetition. Looking at this example closely we can see how the inner loop:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{1}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{2}
\end{sphinxVerbatim}

\sphinxAtStartPar
is repeated 4 times (i.e. the number of repetitions as specified by the outer loop)

\sphinxAtStartPar
Nested loops allow us to create interesting loop patterns. Such as the nested loop below which increases the number of repetitions of the inner loop

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{k}{while} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{4}\PYG{p}{:}
    \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{k}{while} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{i}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{} instead of looping a set amount of times, it loops based on the value of i}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{i=}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{, }\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{j=}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{j} \PYG{o}{=} \PYG{n}{j} \PYG{o}{+} \PYG{l+m+mi}{1}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} prints an empty line}
    \PYG{n}{i} \PYG{o}{=} \PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
i=1, j=0

i=2, j=0
i=2, j=1

i=3, j=0
i=3, j=1
i=3, j=2
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
In the example above we simply change the boolean expression inside the inner loop from \sphinxcode{\sphinxupquote{j < 3}} to \sphinxcode{\sphinxupquote{j < i}}. With this change, the inner loops number of repetitions become dependent on the value of \sphinxcode{\sphinxupquote{i}}. In this case \sphinxcode{\sphinxupquote{i}} is incremented by 1 during every repetition of the outer loop. Because of this, the inner loop’s repetition amount is also incremented by 1.


\section{Infinite loops}
\label{\detokenize{loops:infinite-loops}}
\sphinxAtStartPar
One thing you need to be careful of when it comes to loops is accidentally creating an infinite loop. An infinite loop occurs when the loop has no way of ending.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{while} \PYG{k+kc}{True}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{again}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
If we try to run the code above, we repeat the second line again and again. But since the boolean expression is always True, the loop will never end. If your try to run this code. You’ll see that python will execute the indented line again and again until it cannot anymore.

\sphinxAtStartPar
The example above is very obvious. In some cases you might not notice that you accidentally created an infinite loop

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{k}{while} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{5}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{again}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The example above will also produce an infinte loop. As you can see you missed the line that reassigns the value of i. And since the value of \sphinxcode{\sphinxupquote{i}} doesnt change. Python will keep evaluating \sphinxcode{\sphinxupquote{0 < 5}}, which is always true, resulting in boolean expression that cannot fail, and therefore an infinite loop.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{k}{while} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{5}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{again}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{i} \PYG{o}{=} \PYG{n}{i} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\sphinxAtStartPar
The example above does change the value of \sphinxcode{\sphinxupquote{i}} but because you are decrementing \sphinxcode{\sphinxupquote{i}}. No matter how many times your decrease \sphinxcode{\sphinxupquote{i}} it will not result in the failure of the boolean expression \sphinxcode{\sphinxupquote{i < 5}}. Therefore the boolean expression is always true, causing an infinite loop

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{k}{while} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{5}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{again}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{i} \PYG{o}{=} \PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\sphinxAtStartPar
In the example above we have the correct modification for i, which is increment. But unfortunately we did not put the correct indentation on this line. This means that the \sphinxcode{\sphinxupquote{i = i + 1}} is placed outside of the loop. Which means this line will never be reached until the loop is finsished. And since the loop above is missing the correct increment, it will never finish.


\section{\sphinxstyleliteralintitle{\sphinxupquote{for}} loops}
\label{\detokenize{loops:for-loops}}
\sphinxAtStartPar
Python has special repetition statements that are useful for working with sequence datatypes. These are known as \sphinxcode{\sphinxupquote{for}} loops

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fruits} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Apple}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Banana}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Cherry}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Durian}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

\PYG{k}{for} \PYG{n}{f} \PYG{o+ow}{in} \PYG{n}{fruits}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{f}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Apple
Banana
Cherry
Durian
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
A \sphinxcode{\sphinxupquote{for}} loop goes through the elements of a sequence (lists, tuples, strings, dictionaries, etc.) to allow us to interact with the elements individually.

\sphinxAtStartPar
In the code above, we write \sphinxcode{\sphinxupquote{for f in fruits:}}. A good way to read this line in english is \sphinxstyleemphasis{“for every f in fruits”}.

\sphinxAtStartPar
On the first repetition of the for loop, the first element of \sphinxcode{\sphinxupquote{fruits}} is assigned to the the variable \sphinxcode{\sphinxupquote{f}}. It then proceeds to the indented lines. In this case we have one line which simply prints the value stored in \sphinxcode{\sphinxupquote{f}} which is \sphinxcode{\sphinxupquote{'Apple'}}. It then returns to the start of the loop, but this time reassigning \sphinxcode{\sphinxupquote{f}} to the second element of \sphinxcode{\sphinxupquote{fruits}}. It then proceeds to the indented lines again and prints the value store in \sphinxcode{\sphinxupquote{f}}. This time the stored value is \sphinxcode{\sphinxupquote{Banana}}.

\sphinxAtStartPar
The for loop repeats this process until there are no more elements in \sphinxcode{\sphinxupquote{fruits}}.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{for}} loop above has the same results as the \sphinxcode{\sphinxupquote{while}} loop below:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fruits} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Apple}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Banana}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Cherry}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Durian}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{k}{while} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{fruits}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{f} \PYG{o}{=} \PYG{n}{fruits}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{f}\PYG{p}{)}
    \PYG{n}{i} \PYG{o}{=} \PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Apple
Banana
Cherry
Durian
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
As said before, \sphinxcode{\sphinxupquote{for}} loops will work with other python sequence:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{element} \PYG{o+ow}{in} \PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{element}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
1
2
3
4
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{character} \PYG{o+ow}{in} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{word}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{character}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
w
o
r
d
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{items} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}
\PYG{k}{for} \PYG{n}{key} \PYG{o+ow}{in} \PYG{n}{items}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{key}\PYG{p}{,} \PYG{n}{items}\PYG{p}{[}\PYG{n}{key}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
a 1
b 2
c 3
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}\begin{quote}

\sphinxAtStartPar
As you can see in the code above, \sphinxcode{\sphinxupquote{key}} is assigned to the keys of the entries instead of the values
\end{quote}







\renewcommand{\indexname}{Index}
\printindex
\end{document}